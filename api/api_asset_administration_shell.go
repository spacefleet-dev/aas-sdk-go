//lint:file-ignore * Autogenerated code
/*
BaSyx Asset Administration Shell HTTP REST-API

The full description of the generic BaSyx Asset Administration Shell HTTP REST-API

API version: v1
Contact: constantin.ziesche@bosch.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// AssetAdministrationShellApiService AssetAdministrationShellApi service
type AssetAdministrationShellApiService service

type ApiAasSubmodelsSubmodelIdShortGetRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
}

func (r ApiAasSubmodelsSubmodelIdShortGetRequest) Execute() (*Submodel, *http.Response, error) {
	return r.ApiService.AasSubmodelsSubmodelIdShortGetExecute(r)
}

/*
AasSubmodelsSubmodelIdShortGet Retrieves the Submodel from the Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@return ApiAasSubmodelsSubmodelIdShortGetRequest
*/
func (a *AssetAdministrationShellApiService) AasSubmodelsSubmodelIdShortGet(ctx context.Context, submodelIdShort string) ApiAasSubmodelsSubmodelIdShortGetRequest {
	return ApiAasSubmodelsSubmodelIdShortGetRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
//
//	@return Submodel
func (a *AssetAdministrationShellApiService) AasSubmodelsSubmodelIdShortGetExecute(r ApiAasSubmodelsSubmodelIdShortGetRequest) (*Submodel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Submodel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.AasSubmodelsSubmodelIdShortGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSubmodelFromShellByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
}

func (r ApiDeleteSubmodelFromShellByIdShortRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSubmodelFromShellByIdShortExecute(r)
}

/*
DeleteSubmodelFromShellByIdShort Deletes a specific Submodel from the Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@return ApiDeleteSubmodelFromShellByIdShortRequest
*/
func (a *AssetAdministrationShellApiService) DeleteSubmodelFromShellByIdShort(ctx context.Context, submodelIdShort string) ApiDeleteSubmodelFromShellByIdShortRequest {
	return ApiDeleteSubmodelFromShellByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
func (a *AssetAdministrationShellApiService) DeleteSubmodelFromShellByIdShortExecute(r ApiDeleteSubmodelFromShellByIdShortRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.DeleteSubmodelFromShellByIdShort")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAssetAdministrationShellRequest struct {
	ctx        context.Context
	ApiService *AssetAdministrationShellApiService
}

func (r ApiGetAssetAdministrationShellRequest) Execute() (*AssetAdministrationShellDescriptor, *http.Response, error) {
	return r.ApiService.GetAssetAdministrationShellExecute(r)
}

/*
GetAssetAdministrationShell Retrieves the Asset Administration Shell Descriptor

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAssetAdministrationShellRequest
*/
func (a *AssetAdministrationShellApiService) GetAssetAdministrationShell(ctx context.Context) ApiGetAssetAdministrationShellRequest {
	return ApiGetAssetAdministrationShellRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AssetAdministrationShellDescriptor
func (a *AssetAdministrationShellApiService) GetAssetAdministrationShellExecute(r ApiGetAssetAdministrationShellRequest) (*AssetAdministrationShellDescriptor, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AssetAdministrationShellDescriptor
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.GetAssetAdministrationShell")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubmodelFromShellByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
}

func (r ApiGetSubmodelFromShellByIdShortRequest) Execute() (*Submodel, *http.Response, error) {
	return r.ApiService.GetSubmodelFromShellByIdShortExecute(r)
}

/*
GetSubmodelFromShellByIdShort Retrieves the Submodel from the Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@return ApiGetSubmodelFromShellByIdShortRequest
*/
func (a *AssetAdministrationShellApiService) GetSubmodelFromShellByIdShort(ctx context.Context, submodelIdShort string) ApiGetSubmodelFromShellByIdShortRequest {
	return ApiGetSubmodelFromShellByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
//
//	@return Submodel
func (a *AssetAdministrationShellApiService) GetSubmodelFromShellByIdShortExecute(r ApiGetSubmodelFromShellByIdShortRequest) (*Submodel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Submodel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.GetSubmodelFromShellByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSubmodelsFromShellRequest struct {
	ctx        context.Context
	ApiService *AssetAdministrationShellApiService
}

func (r ApiGetSubmodelsFromShellRequest) Execute() ([]Submodel, *http.Response, error) {
	return r.ApiService.GetSubmodelsFromShellExecute(r)
}

/*
GetSubmodelsFromShell Retrieves all Submodels from the  Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetSubmodelsFromShellRequest
*/
func (a *AssetAdministrationShellApiService) GetSubmodelsFromShell(ctx context.Context) ApiGetSubmodelsFromShellRequest {
	return ApiGetSubmodelsFromShellRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []Submodel
func (a *AssetAdministrationShellApiService) GetSubmodelsFromShellExecute(r ApiGetSubmodelsFromShellRequest) ([]Submodel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []Submodel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.GetSubmodelsFromShell")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutSubmodelToShellRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
	submodel        *Submodel
}

// The serialized Submodel object
func (r ApiPutSubmodelToShellRequest) Submodel(submodel Submodel) ApiPutSubmodelToShellRequest {
	r.submodel = &submodel
	return r
}

func (r ApiPutSubmodelToShellRequest) Execute() (*Submodel, *http.Response, error) {
	return r.ApiService.PutSubmodelToShellExecute(r)
}

/*
PutSubmodelToShell Creates or updates a Submodel to an existing Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@return ApiPutSubmodelToShellRequest
*/
func (a *AssetAdministrationShellApiService) PutSubmodelToShell(ctx context.Context, submodelIdShort string) ApiPutSubmodelToShellRequest {
	return ApiPutSubmodelToShellRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
//
//	@return Submodel
func (a *AssetAdministrationShellApiService) PutSubmodelToShellExecute(r ApiPutSubmodelToShellRequest) (*Submodel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Submodel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.PutSubmodelToShell")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submodel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellDeleteSubmodelElementByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
	seIdShortPath   string
}

func (r ApiShellDeleteSubmodelElementByIdShortRequest) Execute() (*Result, *http.Response, error) {
	return r.ApiService.ShellDeleteSubmodelElementByIdShortExecute(r)
}

/*
ShellDeleteSubmodelElementByIdShort Deletes a specific Submodel-Element from the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellDeleteSubmodelElementByIdShortRequest
*/
func (a *AssetAdministrationShellApiService) ShellDeleteSubmodelElementByIdShort(ctx context.Context, submodelIdShort string, seIdShortPath string) ApiShellDeleteSubmodelElementByIdShortRequest {
	return ApiShellDeleteSubmodelElementByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
//
//	@return Result
func (a *AssetAdministrationShellApiService) ShellDeleteSubmodelElementByIdShortExecute(r ApiShellDeleteSubmodelElementByIdShortRequest) (*Result, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Result
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.ShellDeleteSubmodelElementByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellGetInvocationResultByIdShortRequest struct {
	ctx                    context.Context
	ApiService             *AssetAdministrationShellApiService
	submodelIdShort        string
	idShortPathToOperation string
	requestId              string
}

func (r ApiShellGetInvocationResultByIdShortRequest) Execute() (*InvocationResponse, *http.Response, error) {
	return r.ApiService.ShellGetInvocationResultByIdShortExecute(r)
}

/*
ShellGetInvocationResultByIdShort Retrieves the result of an asynchronously started operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort Submodel's short id
	@param idShortPathToOperation The IdShort path to the Operation
	@param requestId The request id
	@return ApiShellGetInvocationResultByIdShortRequest
*/
func (a *AssetAdministrationShellApiService) ShellGetInvocationResultByIdShort(ctx context.Context, submodelIdShort string, idShortPathToOperation string, requestId string) ApiShellGetInvocationResultByIdShortRequest {
	return ApiShellGetInvocationResultByIdShortRequest{
		ApiService:             a,
		ctx:                    ctx,
		submodelIdShort:        submodelIdShort,
		idShortPathToOperation: idShortPathToOperation,
		requestId:              requestId,
	}
}

// Execute executes the request
//
//	@return InvocationResponse
func (a *AssetAdministrationShellApiService) ShellGetInvocationResultByIdShortExecute(r ApiShellGetInvocationResultByIdShortRequest) (*InvocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InvocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.ShellGetInvocationResultByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel/submodelElements/{idShortPathToOperation}/invocationList/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"idShortPathToOperation"+"}", url.PathEscape(parameterToString(r.idShortPathToOperation, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellGetSubmodelElementByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
	seIdShortPath   string
}

func (r ApiShellGetSubmodelElementByIdShortRequest) Execute() (*SubmodelElement, *http.Response, error) {
	return r.ApiService.ShellGetSubmodelElementByIdShortExecute(r)
}

/*
ShellGetSubmodelElementByIdShort Retrieves a specific Submodel-Element from the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellGetSubmodelElementByIdShortRequest
*/
func (a *AssetAdministrationShellApiService) ShellGetSubmodelElementByIdShort(ctx context.Context, submodelIdShort string, seIdShortPath string) ApiShellGetSubmodelElementByIdShortRequest {
	return ApiShellGetSubmodelElementByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
//
//	@return SubmodelElement
func (a *AssetAdministrationShellApiService) ShellGetSubmodelElementByIdShortExecute(r ApiShellGetSubmodelElementByIdShortRequest) (*SubmodelElement, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmodelElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.ShellGetSubmodelElementByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellGetSubmodelElementValueByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
	seIdShortPath   string
}

func (r ApiShellGetSubmodelElementValueByIdShortRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ShellGetSubmodelElementValueByIdShortExecute(r)
}

/*
ShellGetSubmodelElementValueByIdShort Retrieves the value of a specific Submodel-Element from the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellGetSubmodelElementValueByIdShortRequest
*/
func (a *AssetAdministrationShellApiService) ShellGetSubmodelElementValueByIdShort(ctx context.Context, submodelIdShort string, seIdShortPath string) ApiShellGetSubmodelElementValueByIdShortRequest {
	return ApiShellGetSubmodelElementValueByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AssetAdministrationShellApiService) ShellGetSubmodelElementValueByIdShortExecute(r ApiShellGetSubmodelElementValueByIdShortRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.ShellGetSubmodelElementValueByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}/value"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellGetSubmodelElementsRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
}

func (r ApiShellGetSubmodelElementsRequest) Execute() ([]SubmodelElement, *http.Response, error) {
	return r.ApiService.ShellGetSubmodelElementsExecute(r)
}

/*
ShellGetSubmodelElements Retrieves all Submodel-Elements from the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@return ApiShellGetSubmodelElementsRequest
*/
func (a *AssetAdministrationShellApiService) ShellGetSubmodelElements(ctx context.Context, submodelIdShort string) ApiShellGetSubmodelElementsRequest {
	return ApiShellGetSubmodelElementsRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
//
//	@return []SubmodelElement
func (a *AssetAdministrationShellApiService) ShellGetSubmodelElementsExecute(r ApiShellGetSubmodelElementsRequest) ([]SubmodelElement, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SubmodelElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.ShellGetSubmodelElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel/submodelElements"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellGetSubmodelValuesRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
}

func (r ApiShellGetSubmodelValuesRequest) Execute() (*http.Response, error) {
	return r.ApiService.ShellGetSubmodelValuesExecute(r)
}

/*
ShellGetSubmodelValues Retrieves the minimized version of a Submodel, i.e. only the values of SubmodelElements are serialized and returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@return ApiShellGetSubmodelValuesRequest
*/
func (a *AssetAdministrationShellApiService) ShellGetSubmodelValues(ctx context.Context, submodelIdShort string) ApiShellGetSubmodelValuesRequest {
	return ApiShellGetSubmodelValuesRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
func (a *AssetAdministrationShellApiService) ShellGetSubmodelValuesExecute(r ApiShellGetSubmodelValuesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.ShellGetSubmodelValues")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel/values"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiShellInvokeOperationByIdShortRequest struct {
	ctx                    context.Context
	ApiService             *AssetAdministrationShellApiService
	submodelIdShort        string
	idShortPathToOperation string
	async                  *bool
	invocationRequest      *InvocationRequest
}

// Determines whether the execution of the operation is asynchronous (true) or not (false)
func (r ApiShellInvokeOperationByIdShortRequest) Async(async bool) ApiShellInvokeOperationByIdShortRequest {
	r.async = &async
	return r
}

// The parameterized request object for the invocation
func (r ApiShellInvokeOperationByIdShortRequest) InvocationRequest(invocationRequest InvocationRequest) ApiShellInvokeOperationByIdShortRequest {
	r.invocationRequest = &invocationRequest
	return r
}

func (r ApiShellInvokeOperationByIdShortRequest) Execute() (*http.Response, error) {
	return r.ApiService.ShellInvokeOperationByIdShortExecute(r)
}

/*
ShellInvokeOperationByIdShort Invokes a specific operation from the Submodel synchronously or asynchronously

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort Submodel's short id
	@param idShortPathToOperation The IdShort path to the Operation
	@return ApiShellInvokeOperationByIdShortRequest
*/
func (a *AssetAdministrationShellApiService) ShellInvokeOperationByIdShort(ctx context.Context, submodelIdShort string, idShortPathToOperation string) ApiShellInvokeOperationByIdShortRequest {
	return ApiShellInvokeOperationByIdShortRequest{
		ApiService:             a,
		ctx:                    ctx,
		submodelIdShort:        submodelIdShort,
		idShortPathToOperation: idShortPathToOperation,
	}
}

// Execute executes the request
func (a *AssetAdministrationShellApiService) ShellInvokeOperationByIdShortExecute(r ApiShellInvokeOperationByIdShortRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.ShellInvokeOperationByIdShort")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel/submodelElements/{idShortPathToOperation}/invoke"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"idShortPathToOperation"+"}", url.PathEscape(parameterToString(r.idShortPathToOperation, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		localVarQueryParams.Add("async", parameterToString(*r.async, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invocationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiShellPutSubmodelElementRequest struct {
	ctx              context.Context
	ApiService       *AssetAdministrationShellApiService
	submodelIdShort  string
	seIdShortPath    string
	iSubmodelElement *ISubmodelElement
}

// The Submodel-Element object
func (r ApiShellPutSubmodelElementRequest) ISubmodelElement(iSubmodelElement ISubmodelElement) ApiShellPutSubmodelElementRequest {
	r.iSubmodelElement = &iSubmodelElement
	return r
}

func (r ApiShellPutSubmodelElementRequest) Execute() (*SubmodelElement, *http.Response, error) {
	return r.ApiService.ShellPutSubmodelElementExecute(r)
}

/*
ShellPutSubmodelElement Creates or updates a Submodel-Element at the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellPutSubmodelElementRequest
*/
func (a *AssetAdministrationShellApiService) ShellPutSubmodelElement(ctx context.Context, submodelIdShort string, seIdShortPath string) ApiShellPutSubmodelElementRequest {
	return ApiShellPutSubmodelElementRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
//
//	@return SubmodelElement
func (a *AssetAdministrationShellApiService) ShellPutSubmodelElementExecute(r ApiShellPutSubmodelElementRequest) (*SubmodelElement, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmodelElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.ShellPutSubmodelElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.iSubmodelElement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellPutSubmodelElementValueByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellApiService
	submodelIdShort string
	seIdShortPath   string
	body            *map[string]interface{}
}

// The new value
func (r ApiShellPutSubmodelElementValueByIdShortRequest) Body(body map[string]interface{}) ApiShellPutSubmodelElementValueByIdShortRequest {
	r.body = &body
	return r
}

func (r ApiShellPutSubmodelElementValueByIdShortRequest) Execute() (*ElementValue, *http.Response, error) {
	return r.ApiService.ShellPutSubmodelElementValueByIdShortExecute(r)
}

/*
ShellPutSubmodelElementValueByIdShort Updates the Submodel-Element's value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellPutSubmodelElementValueByIdShortRequest
*/
func (a *AssetAdministrationShellApiService) ShellPutSubmodelElementValueByIdShort(ctx context.Context, submodelIdShort string, seIdShortPath string) ApiShellPutSubmodelElementValueByIdShortRequest {
	return ApiShellPutSubmodelElementValueByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
//
//	@return ElementValue
func (a *AssetAdministrationShellApiService) ShellPutSubmodelElementValueByIdShortExecute(r ApiShellPutSubmodelElementValueByIdShortRequest) (*ElementValue, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ElementValue
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellApiService.ShellPutSubmodelElementValueByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}/value"
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
