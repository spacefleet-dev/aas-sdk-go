/*
BaSyx Asset Administration Shell Repository HTTP REST-API

The full description of the generic BaSyx Asset Administration Shell Repository HTTP REST-API

API version: v1
Contact: constantin.ziesche@bosch.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// AssetAdministrationShellRepositoryApiService AssetAdministrationShellRepositoryApi service
type AssetAdministrationShellRepositoryApiService service

type ApiDeleteAssetAdministrationShellByIdRequest struct {
	ctx        context.Context
	ApiService *AssetAdministrationShellRepositoryApiService
	aasId      string
}

func (r ApiDeleteAssetAdministrationShellByIdRequest) Execute() (*Result, *http.Response, error) {
	return r.ApiService.DeleteAssetAdministrationShellByIdExecute(r)
}

/*
DeleteAssetAdministrationShellById Deletes a specific Asset Administration Shell at the Asset Administration Shell repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@return ApiDeleteAssetAdministrationShellByIdRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) DeleteAssetAdministrationShellById(ctx context.Context, aasId string) ApiDeleteAssetAdministrationShellByIdRequest {
	return ApiDeleteAssetAdministrationShellByIdRequest{
		ApiService: a,
		ctx:        ctx,
		aasId:      aasId,
	}
}

// Execute executes the request
//
//	@return Result
func (a *AssetAdministrationShellRepositoryApiService) DeleteAssetAdministrationShellByIdExecute(r ApiDeleteAssetAdministrationShellByIdRequest) (*Result, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Result
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.DeleteAssetAdministrationShellById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllAssetAdministrationShellsRequest struct {
	ctx        context.Context
	ApiService *AssetAdministrationShellRepositoryApiService
}

func (r ApiGetAllAssetAdministrationShellsRequest) Execute() ([]AssetAdministrationShell, *http.Response, error) {
	return r.ApiService.GetAllAssetAdministrationShellsExecute(r)
}

/*
GetAllAssetAdministrationShells Retrieves all Asset Administration Shells from the Asset Administration Shell repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiGetAllAssetAdministrationShellsRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) GetAllAssetAdministrationShells(ctx context.Context) ApiGetAllAssetAdministrationShellsRequest {
	return ApiGetAllAssetAdministrationShellsRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return []AssetAdministrationShell
func (a *AssetAdministrationShellRepositoryApiService) GetAllAssetAdministrationShellsExecute(r ApiGetAllAssetAdministrationShellsRequest) ([]AssetAdministrationShell, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []AssetAdministrationShell
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.GetAllAssetAdministrationShells")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAssetAdministrationShellByIdRequest struct {
	ctx        context.Context
	ApiService *AssetAdministrationShellRepositoryApiService
	aasId      string
}

func (r ApiGetAssetAdministrationShellByIdRequest) Execute() (*AssetAdministrationShell, *http.Response, error) {
	return r.ApiService.GetAssetAdministrationShellByIdExecute(r)
}

/*
GetAssetAdministrationShellById Retrieves a specific Asset Administration Shell from the Asset Administration Shell repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@return ApiGetAssetAdministrationShellByIdRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) GetAssetAdministrationShellById(ctx context.Context, aasId string) ApiGetAssetAdministrationShellByIdRequest {
	return ApiGetAssetAdministrationShellByIdRequest{
		ApiService: a,
		ctx:        ctx,
		aasId:      aasId,
	}
}

// Execute executes the request
//
//	@return AssetAdministrationShell
func (a *AssetAdministrationShellRepositoryApiService) GetAssetAdministrationShellByIdExecute(r ApiGetAssetAdministrationShellByIdRequest) (*AssetAdministrationShell, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AssetAdministrationShell
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.GetAssetAdministrationShellById")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutAssetAdministrationShellRequest struct {
	ctx                      context.Context
	ApiService               *AssetAdministrationShellRepositoryApiService
	aasId                    string
	assetAdministrationShell *AssetAdministrationShell
}

// The Asset Administration Shell
func (r ApiPutAssetAdministrationShellRequest) AssetAdministrationShell(assetAdministrationShell AssetAdministrationShell) ApiPutAssetAdministrationShellRequest {
	r.assetAdministrationShell = &assetAdministrationShell
	return r
}

func (r ApiPutAssetAdministrationShellRequest) Execute() (*AssetAdministrationShell, *http.Response, error) {
	return r.ApiService.PutAssetAdministrationShellExecute(r)
}

/*
PutAssetAdministrationShell Creates or updates a Asset Administration Shell at the Asset Administration Shell repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@return ApiPutAssetAdministrationShellRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) PutAssetAdministrationShell(ctx context.Context, aasId string) ApiPutAssetAdministrationShellRequest {
	return ApiPutAssetAdministrationShellRequest{
		ApiService: a,
		ctx:        ctx,
		aasId:      aasId,
	}
}

// Execute executes the request
//
//	@return AssetAdministrationShell
func (a *AssetAdministrationShellRepositoryApiService) PutAssetAdministrationShellExecute(r ApiPutAssetAdministrationShellRequest) (*AssetAdministrationShell, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AssetAdministrationShell
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.PutAssetAdministrationShell")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.assetAdministrationShell
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellRepoDeleteSubmodelElementByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
	seIdShortPath   string
}

func (r ApiShellRepoDeleteSubmodelElementByIdShortRequest) Execute() (*Result, *http.Response, error) {
	return r.ApiService.ShellRepoDeleteSubmodelElementByIdShortExecute(r)
}

/*
ShellRepoDeleteSubmodelElementByIdShort Deletes a specific Submodel-Element from the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellRepoDeleteSubmodelElementByIdShortRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoDeleteSubmodelElementByIdShort(ctx context.Context, aasId string, submodelIdShort string, seIdShortPath string) ApiShellRepoDeleteSubmodelElementByIdShortRequest {
	return ApiShellRepoDeleteSubmodelElementByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
//
//	@return Result
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoDeleteSubmodelElementByIdShortExecute(r ApiShellRepoDeleteSubmodelElementByIdShortRequest) (*Result, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodDelete
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Result
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoDeleteSubmodelElementByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellRepoDeleteSubmodelFromShellByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
}

func (r ApiShellRepoDeleteSubmodelFromShellByIdShortRequest) Execute() (*http.Response, error) {
	return r.ApiService.ShellRepoDeleteSubmodelFromShellByIdShortExecute(r)
}

/*
ShellRepoDeleteSubmodelFromShellByIdShort Deletes a specific Submodel from the Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@return ApiShellRepoDeleteSubmodelFromShellByIdShortRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoDeleteSubmodelFromShellByIdShort(ctx context.Context, aasId string, submodelIdShort string) ApiShellRepoDeleteSubmodelFromShellByIdShortRequest {
	return ApiShellRepoDeleteSubmodelFromShellByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoDeleteSubmodelFromShellByIdShortExecute(r ApiShellRepoDeleteSubmodelFromShellByIdShortRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodDelete
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoDeleteSubmodelFromShellByIdShort")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiShellRepoGetInvocationResultByIdShortRequest struct {
	ctx                    context.Context
	ApiService             *AssetAdministrationShellRepositoryApiService
	aasId                  string
	submodelIdShort        string
	idShortPathToOperation string
	requestId              string
}

func (r ApiShellRepoGetInvocationResultByIdShortRequest) Execute() (*InvocationResponse, *http.Response, error) {
	return r.ApiService.ShellRepoGetInvocationResultByIdShortExecute(r)
}

/*
ShellRepoGetInvocationResultByIdShort Retrieves the result of an asynchronously started operation

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort Submodel's short id
	@param idShortPathToOperation The IdShort path to the Operation
	@param requestId The request id
	@return ApiShellRepoGetInvocationResultByIdShortRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetInvocationResultByIdShort(ctx context.Context, aasId string, submodelIdShort string, idShortPathToOperation string, requestId string) ApiShellRepoGetInvocationResultByIdShortRequest {
	return ApiShellRepoGetInvocationResultByIdShortRequest{
		ApiService:             a,
		ctx:                    ctx,
		aasId:                  aasId,
		submodelIdShort:        submodelIdShort,
		idShortPathToOperation: idShortPathToOperation,
		requestId:              requestId,
	}
}

// Execute executes the request
//
//	@return InvocationResponse
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetInvocationResultByIdShortExecute(r ApiShellRepoGetInvocationResultByIdShortRequest) (*InvocationResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *InvocationResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoGetInvocationResultByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel/submodelElements/{idShortPathToOperation}/invocationList/{requestId}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"idShortPathToOperation"+"}", url.PathEscape(parameterToString(r.idShortPathToOperation, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"requestId"+"}", url.PathEscape(parameterToString(r.requestId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellRepoGetSubmodelElementByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
	seIdShortPath   string
}

func (r ApiShellRepoGetSubmodelElementByIdShortRequest) Execute() (*SubmodelElement, *http.Response, error) {
	return r.ApiService.ShellRepoGetSubmodelElementByIdShortExecute(r)
}

/*
ShellRepoGetSubmodelElementByIdShort Retrieves a specific Submodel-Element from the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellRepoGetSubmodelElementByIdShortRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelElementByIdShort(ctx context.Context, aasId string, submodelIdShort string, seIdShortPath string) ApiShellRepoGetSubmodelElementByIdShortRequest {
	return ApiShellRepoGetSubmodelElementByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
//
//	@return SubmodelElement
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelElementByIdShortExecute(r ApiShellRepoGetSubmodelElementByIdShortRequest) (*SubmodelElement, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmodelElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoGetSubmodelElementByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellRepoGetSubmodelElementValueByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
	seIdShortPath   string
}

func (r ApiShellRepoGetSubmodelElementValueByIdShortRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.ShellRepoGetSubmodelElementValueByIdShortExecute(r)
}

/*
ShellRepoGetSubmodelElementValueByIdShort Retrieves the value of a specific Submodel-Element from the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellRepoGetSubmodelElementValueByIdShortRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelElementValueByIdShort(ctx context.Context, aasId string, submodelIdShort string, seIdShortPath string) ApiShellRepoGetSubmodelElementValueByIdShortRequest {
	return ApiShellRepoGetSubmodelElementValueByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
//
//	@return map[string]interface{}
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelElementValueByIdShortExecute(r ApiShellRepoGetSubmodelElementValueByIdShortRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoGetSubmodelElementValueByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}/value"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 405 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellRepoGetSubmodelElementsRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
}

func (r ApiShellRepoGetSubmodelElementsRequest) Execute() ([]SubmodelElement, *http.Response, error) {
	return r.ApiService.ShellRepoGetSubmodelElementsExecute(r)
}

/*
ShellRepoGetSubmodelElements Retrieves all Submodel-Elements from the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@return ApiShellRepoGetSubmodelElementsRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelElements(ctx context.Context, aasId string, submodelIdShort string) ApiShellRepoGetSubmodelElementsRequest {
	return ApiShellRepoGetSubmodelElementsRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
//
//	@return []SubmodelElement
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelElementsExecute(r ApiShellRepoGetSubmodelElementsRequest) ([]SubmodelElement, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue []SubmodelElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoGetSubmodelElements")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel/submodelElements"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellRepoGetSubmodelFromShellByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
}

func (r ApiShellRepoGetSubmodelFromShellByIdShortRequest) Execute() (*Submodel, *http.Response, error) {
	return r.ApiService.ShellRepoGetSubmodelFromShellByIdShortExecute(r)
}

/*
ShellRepoGetSubmodelFromShellByIdShort Retrieves the Submodel from the Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@return ApiShellRepoGetSubmodelFromShellByIdShortRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelFromShellByIdShort(ctx context.Context, aasId string, submodelIdShort string) ApiShellRepoGetSubmodelFromShellByIdShortRequest {
	return ApiShellRepoGetSubmodelFromShellByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
//
//	@return Submodel
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelFromShellByIdShortExecute(r ApiShellRepoGetSubmodelFromShellByIdShortRequest) (*Submodel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Submodel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoGetSubmodelFromShellByIdShort")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellRepoGetSubmodelValuesRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
}

func (r ApiShellRepoGetSubmodelValuesRequest) Execute() (*http.Response, error) {
	return r.ApiService.ShellRepoGetSubmodelValuesExecute(r)
}

/*
ShellRepoGetSubmodelValues Retrieves the minimized version of a Submodel, i.e. only the values of SubmodelElements are serialized and returned

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@return ApiShellRepoGetSubmodelValuesRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelValues(ctx context.Context, aasId string, submodelIdShort string) ApiShellRepoGetSubmodelValuesRequest {
	return ApiShellRepoGetSubmodelValuesRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelValuesExecute(r ApiShellRepoGetSubmodelValuesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodGet
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoGetSubmodelValues")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel/values"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiShellRepoGetSubmodelsFromShellRequest struct {
	ctx        context.Context
	ApiService *AssetAdministrationShellRepositoryApiService
	aasId      string
}

func (r ApiShellRepoGetSubmodelsFromShellRequest) Execute() (*Result, *http.Response, error) {
	return r.ApiService.ShellRepoGetSubmodelsFromShellExecute(r)
}

/*
ShellRepoGetSubmodelsFromShell Retrieves all Submodels from the  Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@return ApiShellRepoGetSubmodelsFromShellRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelsFromShell(ctx context.Context, aasId string) ApiShellRepoGetSubmodelsFromShellRequest {
	return ApiShellRepoGetSubmodelsFromShellRequest{
		ApiService: a,
		ctx:        ctx,
		aasId:      aasId,
	}
}

// Execute executes the request
//
//	@return Result
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoGetSubmodelsFromShellExecute(r ApiShellRepoGetSubmodelsFromShellRequest) (*Result, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Result
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoGetSubmodelsFromShell")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellRepoInvokeOperationByIdShortRequest struct {
	ctx                    context.Context
	ApiService             *AssetAdministrationShellRepositoryApiService
	aasId                  string
	submodelIdShort        string
	idShortPathToOperation string
	async                  *bool
	invocationRequest      *InvocationRequest
}

// Determines whether the execution of the operation is asynchronous (true) or not (false)
func (r ApiShellRepoInvokeOperationByIdShortRequest) Async(async bool) ApiShellRepoInvokeOperationByIdShortRequest {
	r.async = &async
	return r
}

// The parameterized request object for the invocation
func (r ApiShellRepoInvokeOperationByIdShortRequest) InvocationRequest(invocationRequest InvocationRequest) ApiShellRepoInvokeOperationByIdShortRequest {
	r.invocationRequest = &invocationRequest
	return r
}

func (r ApiShellRepoInvokeOperationByIdShortRequest) Execute() (*http.Response, error) {
	return r.ApiService.ShellRepoInvokeOperationByIdShortExecute(r)
}

/*
ShellRepoInvokeOperationByIdShort Invokes a specific operation from the Submodel synchronously or asynchronously

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort Submodel's short id
	@param idShortPathToOperation The IdShort path to the Operation
	@return ApiShellRepoInvokeOperationByIdShortRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoInvokeOperationByIdShort(ctx context.Context, aasId string, submodelIdShort string, idShortPathToOperation string) ApiShellRepoInvokeOperationByIdShortRequest {
	return ApiShellRepoInvokeOperationByIdShortRequest{
		ApiService:             a,
		ctx:                    ctx,
		aasId:                  aasId,
		submodelIdShort:        submodelIdShort,
		idShortPathToOperation: idShortPathToOperation,
	}
}

// Execute executes the request
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoInvokeOperationByIdShortExecute(r ApiShellRepoInvokeOperationByIdShortRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoInvokeOperationByIdShort")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel/submodelElements/{idShortPathToOperation}/invoke"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"idShortPathToOperation"+"}", url.PathEscape(parameterToString(r.idShortPathToOperation, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.async != nil {
		localVarQueryParams.Add("async", parameterToString(*r.async, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invocationRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiShellRepoPutSubmodelElementRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
	seIdShortPath   string
	submodelElement *SubmodelElement
}

// The Submodel-Element object
func (r ApiShellRepoPutSubmodelElementRequest) SubmodelElement(submodelElement SubmodelElement) ApiShellRepoPutSubmodelElementRequest {
	r.submodelElement = &submodelElement
	return r
}

func (r ApiShellRepoPutSubmodelElementRequest) Execute() (*SubmodelElement, *http.Response, error) {
	return r.ApiService.ShellRepoPutSubmodelElementExecute(r)
}

/*
ShellRepoPutSubmodelElement Creates or updates a Submodel-Element at the Submodel

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellRepoPutSubmodelElementRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoPutSubmodelElement(ctx context.Context, aasId string, submodelIdShort string, seIdShortPath string) ApiShellRepoPutSubmodelElementRequest {
	return ApiShellRepoPutSubmodelElementRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
//
//	@return SubmodelElement
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoPutSubmodelElementExecute(r ApiShellRepoPutSubmodelElementRequest) (*SubmodelElement, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *SubmodelElement
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoPutSubmodelElement")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submodelElement
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellRepoPutSubmodelElementValueByIdShortRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
	seIdShortPath   string
	body            *map[string]interface{}
}

// The new value
func (r ApiShellRepoPutSubmodelElementValueByIdShortRequest) Body(body map[string]interface{}) ApiShellRepoPutSubmodelElementValueByIdShortRequest {
	r.body = &body
	return r
}

func (r ApiShellRepoPutSubmodelElementValueByIdShortRequest) Execute() (*http.Response, error) {
	return r.ApiService.ShellRepoPutSubmodelElementValueByIdShortExecute(r)
}

/*
ShellRepoPutSubmodelElementValueByIdShort Updates the Submodel-Element's value

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@param seIdShortPath The Submodel-Element's IdShort-Path
	@return ApiShellRepoPutSubmodelElementValueByIdShortRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoPutSubmodelElementValueByIdShort(ctx context.Context, aasId string, submodelIdShort string, seIdShortPath string) ApiShellRepoPutSubmodelElementValueByIdShortRequest {
	return ApiShellRepoPutSubmodelElementValueByIdShortRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
		seIdShortPath:   seIdShortPath,
	}
}

// Execute executes the request
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoPutSubmodelElementValueByIdShortExecute(r ApiShellRepoPutSubmodelElementValueByIdShortRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPut
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoPutSubmodelElementValueByIdShort")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}/submodel/submodelElements/{seIdShortPath}/value"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seIdShortPath"+"}", url.PathEscape(parameterToString(r.seIdShortPath, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.body
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarHTTPResponse, newErr
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiShellRepoPutSubmodelToShellRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
	submodel        *Submodel
}

// The serialized Submodel object
func (r ApiShellRepoPutSubmodelToShellRequest) Submodel(submodel Submodel) ApiShellRepoPutSubmodelToShellRequest {
	r.submodel = &submodel
	return r
}

func (r ApiShellRepoPutSubmodelToShellRequest) Execute() (*Submodel, *http.Response, error) {
	return r.ApiService.ShellRepoPutSubmodelToShellExecute(r)
}

/*
ShellRepoPutSubmodelToShell Creates or updates a Submodel to an existing Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@return ApiShellRepoPutSubmodelToShellRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoPutSubmodelToShell(ctx context.Context, aasId string, submodelIdShort string) ApiShellRepoPutSubmodelToShellRequest {
	return ApiShellRepoPutSubmodelToShellRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
//
//	@return Submodel
func (a *AssetAdministrationShellRepositoryApiService) ShellRepoPutSubmodelToShellExecute(r ApiShellRepoPutSubmodelToShellRequest) (*Submodel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPut
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Submodel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellRepoPutSubmodelToShell")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.submodel
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellsAasIdAasSubmodelsSubmodelIdShortGetRequest struct {
	ctx             context.Context
	ApiService      *AssetAdministrationShellRepositoryApiService
	aasId           string
	submodelIdShort string
}

func (r ApiShellsAasIdAasSubmodelsSubmodelIdShortGetRequest) Execute() (*Submodel, *http.Response, error) {
	return r.ApiService.ShellsAasIdAasSubmodelsSubmodelIdShortGetExecute(r)
}

/*
ShellsAasIdAasSubmodelsSubmodelIdShortGet Retrieves the Submodel from the Asset Administration Shell

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@param submodelIdShort The Submodel's short id
	@return ApiShellsAasIdAasSubmodelsSubmodelIdShortGetRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellsAasIdAasSubmodelsSubmodelIdShortGet(ctx context.Context, aasId string, submodelIdShort string) ApiShellsAasIdAasSubmodelsSubmodelIdShortGetRequest {
	return ApiShellsAasIdAasSubmodelsSubmodelIdShortGetRequest{
		ApiService:      a,
		ctx:             ctx,
		aasId:           aasId,
		submodelIdShort: submodelIdShort,
	}
}

// Execute executes the request
//
//	@return Submodel
func (a *AssetAdministrationShellRepositoryApiService) ShellsAasIdAasSubmodelsSubmodelIdShortGetExecute(r ApiShellsAasIdAasSubmodelsSubmodelIdShortGetRequest) (*Submodel, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *Submodel
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellsAasIdAasSubmodelsSubmodelIdShortGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}/aas/submodels/{submodelIdShort}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"submodelIdShort"+"}", url.PathEscape(parameterToString(r.submodelIdShort, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v Result
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiShellsAasIdGetRequest struct {
	ctx        context.Context
	ApiService *AssetAdministrationShellRepositoryApiService
	aasId      string
}

func (r ApiShellsAasIdGetRequest) Execute() (*AssetAdministrationShell, *http.Response, error) {
	return r.ApiService.ShellsAasIdGetExecute(r)
}

/*
ShellsAasIdGet Retrieves a specific Asset Administration Shell from the Asset Administration Shell repository

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param aasId The Asset Administration Shell's unique id
	@return ApiShellsAasIdGetRequest
*/
func (a *AssetAdministrationShellRepositoryApiService) ShellsAasIdGet(ctx context.Context, aasId string) ApiShellsAasIdGetRequest {
	return ApiShellsAasIdGetRequest{
		ApiService: a,
		ctx:        ctx,
		aasId:      aasId,
	}
}

// Execute executes the request
//
//	@return AssetAdministrationShell
func (a *AssetAdministrationShellRepositoryApiService) ShellsAasIdGetExecute(r ApiShellsAasIdGetRequest) (*AssetAdministrationShell, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodGet
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AssetAdministrationShell
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AssetAdministrationShellRepositoryApiService.ShellsAasIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/shells/{aasId}"
	localVarPath = strings.Replace(localVarPath, "{"+"aasId"+"}", url.PathEscape(parameterToString(r.aasId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
