//lint:file-ignore * Autogenerated code
/*
BaSyx Asset Administration Shell Repository HTTP REST-API

The full description of the generic BaSyx Asset Administration Shell Repository HTTP REST-API

API version: v1
Contact: constantin.ziesche@bosch.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// DataTypeDefXsd the model 'DataTypeDefXsd'
type DataTypeDefXsd string

// List of DataTypeDefXsd
const (
	DATATYPEDEFXSD_NON_NEGATIVE_INTEGER DataTypeDefXsd = "xs:NonNegativeInteger"
	DATATYPEDEFXSD_ANY_URI              DataTypeDefXsd = "xs:anyURI"
	DATATYPEDEFXSD_BASE64_BINARY        DataTypeDefXsd = "xs:base64Binary"
	DATATYPEDEFXSD_BOOLEAN              DataTypeDefXsd = "xs:boolean"
	DATATYPEDEFXSD_BYTE                 DataTypeDefXsd = "xs:byte"
	DATATYPEDEFXSD_DATE                 DataTypeDefXsd = "xs:date"
	DATATYPEDEFXSD_DATE_TIME            DataTypeDefXsd = "xs:dateTime"
	DATATYPEDEFXSD_DATE_TIME_STAMP      DataTypeDefXsd = "xs:dateTimeStamp"
	DATATYPEDEFXSD_DAY_TIME_DURATION    DataTypeDefXsd = "xs:dayTimeDuration"
	DATATYPEDEFXSD_DECIMAL              DataTypeDefXsd = "xs:decimal"
	DATATYPEDEFXSD_DOUBLE               DataTypeDefXsd = "xs:double"
	DATATYPEDEFXSD_DURATION             DataTypeDefXsd = "xs:duration"
	DATATYPEDEFXSD_FLOAT                DataTypeDefXsd = "xs:float"
	DATATYPEDEFXSD_G_DAY                DataTypeDefXsd = "xs:gDay"
	DATATYPEDEFXSD_G_MONTH              DataTypeDefXsd = "xs:gMonth"
	DATATYPEDEFXSD_G_MONTH_DAY          DataTypeDefXsd = "xs:gMonthDay"
	DATATYPEDEFXSD_G_YEAR               DataTypeDefXsd = "xs:gYear"
	DATATYPEDEFXSD_G_YEAR_MONTH         DataTypeDefXsd = "xs:gYearMonth"
	DATATYPEDEFXSD_HEX_BINARY           DataTypeDefXsd = "xs:hexBinary"
	DATATYPEDEFXSD_INT                  DataTypeDefXsd = "xs:int"
	DATATYPEDEFXSD_INTEGER              DataTypeDefXsd = "xs:integer"
	DATATYPEDEFXSD_LONG                 DataTypeDefXsd = "xs:long"
	DATATYPEDEFXSD_NEGATIVE_INTEGER     DataTypeDefXsd = "xs:negativeInteger"
	DATATYPEDEFXSD_NON_POSITIVE_INTEGER DataTypeDefXsd = "xs:nonPositiveInteger"
	DATATYPEDEFXSD_POSITIVE_INTEGER     DataTypeDefXsd = "xs:positiveInteger"
	DATATYPEDEFXSD_SHORT                DataTypeDefXsd = "xs:short"
	DATATYPEDEFXSD_STRING               DataTypeDefXsd = "xs:string"
	DATATYPEDEFXSD_TIME                 DataTypeDefXsd = "xs:time"
	DATATYPEDEFXSD_UNSIGNED_BYTE        DataTypeDefXsd = "xs:unsignedByte"
	DATATYPEDEFXSD_UNSIGNED_INT         DataTypeDefXsd = "xs:unsignedInt"
	DATATYPEDEFXSD_UNSIGNED_LONG        DataTypeDefXsd = "xs:unsignedLong"
	DATATYPEDEFXSD_UNSIGNED_SHORT       DataTypeDefXsd = "xs:unsignedShort"
	DATATYPEDEFXSD_YEAR_MONTH_DURATION  DataTypeDefXsd = "xs:yearMonthDuration"
)

// All allowed values of DataTypeDefXsd enum
var AllowedDataTypeDefXsdEnumValues = []DataTypeDefXsd{
	"xs:NonNegativeInteger",
	"xs:anyURI",
	"xs:base64Binary",
	"xs:boolean",
	"xs:byte",
	"xs:date",
	"xs:dateTime",
	"xs:dateTimeStamp",
	"xs:dayTimeDuration",
	"xs:decimal",
	"xs:double",
	"xs:duration",
	"xs:float",
	"xs:gDay",
	"xs:gMonth",
	"xs:gMonthDay",
	"xs:gYear",
	"xs:gYearMonth",
	"xs:hexBinary",
	"xs:int",
	"xs:integer",
	"xs:long",
	"xs:negativeInteger",
	"xs:nonPositiveInteger",
	"xs:positiveInteger",
	"xs:short",
	"xs:string",
	"xs:time",
	"xs:unsignedByte",
	"xs:unsignedInt",
	"xs:unsignedLong",
	"xs:unsignedShort",
	"xs:yearMonthDuration",
}

func (v *DataTypeDefXsd) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := DataTypeDefXsd(value)
	for _, existing := range AllowedDataTypeDefXsdEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid DataTypeDefXsd", value)
}

// NewDataTypeDefXsdFromValue returns a pointer to a valid DataTypeDefXsd
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewDataTypeDefXsdFromValue(v string) (*DataTypeDefXsd, error) {
	ev := DataTypeDefXsd(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for DataTypeDefXsd: valid values are %v", v, AllowedDataTypeDefXsdEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v DataTypeDefXsd) IsValid() bool {
	for _, existing := range AllowedDataTypeDefXsdEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to DataTypeDefXsd value
func (v DataTypeDefXsd) Ptr() *DataTypeDefXsd {
	return &v
}

type NullableDataTypeDefXsd struct {
	value *DataTypeDefXsd
	isSet bool
}

func (v NullableDataTypeDefXsd) Get() *DataTypeDefXsd {
	return v.value
}

func (v *NullableDataTypeDefXsd) Set(val *DataTypeDefXsd) {
	v.value = val
	v.isSet = true
}

func (v NullableDataTypeDefXsd) IsSet() bool {
	return v.isSet
}

func (v *NullableDataTypeDefXsd) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDataTypeDefXsd(val *DataTypeDefXsd) *NullableDataTypeDefXsd {
	return &NullableDataTypeDefXsd{value: val, isSet: true}
}

func (v NullableDataTypeDefXsd) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDataTypeDefXsd) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
