//lint:file-ignore * Autogenerated code
/*
BaSyx Asset Administration Shell Repository HTTP REST-API

The full description of the generic BaSyx Asset Administration Shell Repository HTTP REST-API

API version: v1
Contact: constantin.ziesche@bosch.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// DataTypeIEC61360 the model 'DataTypeIEC61360'
type DataTypeIEC61360 string

// List of DataTypeIEC61360
const (
	DATATYPEIEC61360_BLOB                DataTypeIEC61360 = "BLOB"
	DATATYPEIEC61360_BOOLEAN             DataTypeIEC61360 = "BOOLEAN"
	DATATYPEIEC61360_DATE                DataTypeIEC61360 = "DATE"
	DATATYPEIEC61360_FILE                DataTypeIEC61360 = "FILE"
	DATATYPEIEC61360_HTML                DataTypeIEC61360 = "HTML"
	DATATYPEIEC61360_INTEGER_COUNT       DataTypeIEC61360 = "INTEGER_COUNT"
	DATATYPEIEC61360_INTEGER_CURRENCY    DataTypeIEC61360 = "INTEGER_CURRENCY"
	DATATYPEIEC61360_INTEGER_MEASURE     DataTypeIEC61360 = "INTEGER_MEASURE"
	DATATYPEIEC61360_IRDI                DataTypeIEC61360 = "IRDI"
	DATATYPEIEC61360_IRI                 DataTypeIEC61360 = "IRI"
	DATATYPEIEC61360_RATIONAL            DataTypeIEC61360 = "RATIONAL"
	DATATYPEIEC61360_RATIONAL_MEASURE    DataTypeIEC61360 = "RATIONAL_MEASURE"
	DATATYPEIEC61360_REAL_COUNT          DataTypeIEC61360 = "REAL_COUNT"
	DATATYPEIEC61360_REAL_CURRENCY       DataTypeIEC61360 = "REAL_CURRENCY"
	DATATYPEIEC61360_REAL_MEASURE        DataTypeIEC61360 = "REAL_MEASURE"
	DATATYPEIEC61360_STRING              DataTypeIEC61360 = "STRING"
	DATATYPEIEC61360_STRING_TRANSLATABLE DataTypeIEC61360 = "STRING_TRANSLATABLE"
	DATATYPEIEC61360_TIME                DataTypeIEC61360 = "TIME"
	DATATYPEIEC61360_TIMESTAMP           DataTypeIEC61360 = "TIMESTAMP"
)

// All allowed values of DataTypeIEC61360 enum
var AllowedDataTypeIEC61360EnumValues = []DataTypeIEC61360{
	"BLOB",
	"BOOLEAN",
	"DATE",
	"FILE",
	"HTML",
	"INTEGER_COUNT",
	"INTEGER_CURRENCY",
	"INTEGER_MEASURE",
	"IRDI",
	"IRI",
	"RATIONAL",
	"RATIONAL_MEASURE",
	"REAL_COUNT",
	"REAL_CURRENCY",
	"REAL_MEASURE",
	"STRING",
	"STRING_TRANSLATABLE",
	"TIME",
	"TIMESTAMP",
}

func (v *DataTypeIEC61360) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := DataTypeIEC61360(value)
	for _, existing := range AllowedDataTypeIEC61360EnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid DataTypeIEC61360", value)
}

// NewDataTypeIEC61360FromValue returns a pointer to a valid DataTypeIEC61360
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewDataTypeIEC61360FromValue(v string) (*DataTypeIEC61360, error) {
	ev := DataTypeIEC61360(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for DataTypeIEC61360: valid values are %v", v, AllowedDataTypeIEC61360EnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v DataTypeIEC61360) IsValid() bool {
	for _, existing := range AllowedDataTypeIEC61360EnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to DataTypeIEC61360 value
func (v DataTypeIEC61360) Ptr() *DataTypeIEC61360 {
	return &v
}

type NullableDataTypeIEC61360 struct {
	value *DataTypeIEC61360
	isSet bool
}

func (v NullableDataTypeIEC61360) Get() *DataTypeIEC61360 {
	return v.value
}

func (v *NullableDataTypeIEC61360) Set(val *DataTypeIEC61360) {
	v.value = val
	v.isSet = true
}

func (v NullableDataTypeIEC61360) IsSet() bool {
	return v.isSet
}

func (v *NullableDataTypeIEC61360) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableDataTypeIEC61360(val *DataTypeIEC61360) *NullableDataTypeIEC61360 {
	return &NullableDataTypeIEC61360{value: val, isSet: true}
}

func (v NullableDataTypeIEC61360) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableDataTypeIEC61360) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
