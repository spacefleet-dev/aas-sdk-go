/*
BaSyx Asset Administration Shell Repository HTTP REST-API

The full description of the generic BaSyx Asset Administration Shell Repository HTTP REST-API

API version: v1
Contact: constantin.ziesche@bosch.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// ISubmodelElement - struct for ISubmodelElement
type ISubmodelElement struct {
	AnnotatedRelationshipElement *AnnotatedRelationshipElement
	BasicEventElement            *BasicEventElement
	Blob                         *Blob
	Entity                       *Entity
	File                         *File
	MultiLanguageProperty        *MultiLanguageProperty
	Operation                    *Operation
	Property                     *Property
	Range                        *Range
	ReferenceElement             *ReferenceElement
	RelationshipElement          *RelationshipElement
	SubmodelElement              *SubmodelElement
	SubmodelElementCollection    *SubmodelElementCollection
	SubmodelElementList          *SubmodelElementList
}

// AnnotatedRelationshipElementAsISubmodelElement is a convenience function that returns AnnotatedRelationshipElement wrapped in ISubmodelElement
func AnnotatedRelationshipElementAsISubmodelElement(v *AnnotatedRelationshipElement) ISubmodelElement {
	return ISubmodelElement{
		AnnotatedRelationshipElement: v,
	}
}

// BasicEventElementAsISubmodelElement is a convenience function that returns BasicEventElement wrapped in ISubmodelElement
func BasicEventElementAsISubmodelElement(v *BasicEventElement) ISubmodelElement {
	return ISubmodelElement{
		BasicEventElement: v,
	}
}

// BlobAsISubmodelElement is a convenience function that returns Blob wrapped in ISubmodelElement
func BlobAsISubmodelElement(v *Blob) ISubmodelElement {
	return ISubmodelElement{
		Blob: v,
	}
}

// EntityAsISubmodelElement is a convenience function that returns Entity wrapped in ISubmodelElement
func EntityAsISubmodelElement(v *Entity) ISubmodelElement {
	return ISubmodelElement{
		Entity: v,
	}
}

// FileAsISubmodelElement is a convenience function that returns File wrapped in ISubmodelElement
func FileAsISubmodelElement(v *File) ISubmodelElement {
	return ISubmodelElement{
		File: v,
	}
}

// MultiLanguagePropertyAsISubmodelElement is a convenience function that returns MultiLanguageProperty wrapped in ISubmodelElement
func MultiLanguagePropertyAsISubmodelElement(v *MultiLanguageProperty) ISubmodelElement {
	return ISubmodelElement{
		MultiLanguageProperty: v,
	}
}

// OperationAsISubmodelElement is a convenience function that returns Operation wrapped in ISubmodelElement
func OperationAsISubmodelElement(v *Operation) ISubmodelElement {
	return ISubmodelElement{
		Operation: v,
	}
}

// PropertyAsISubmodelElement is a convenience function that returns Property wrapped in ISubmodelElement
func PropertyAsISubmodelElement(v *Property) ISubmodelElement {
	return ISubmodelElement{
		Property: v,
	}
}

// RangeAsISubmodelElement is a convenience function that returns Range wrapped in ISubmodelElement
func RangeAsISubmodelElement(v *Range) ISubmodelElement {
	return ISubmodelElement{
		Range: v,
	}
}

// ReferenceElementAsISubmodelElement is a convenience function that returns ReferenceElement wrapped in ISubmodelElement
func ReferenceElementAsISubmodelElement(v *ReferenceElement) ISubmodelElement {
	return ISubmodelElement{
		ReferenceElement: v,
	}
}

// RelationshipElementAsISubmodelElement is a convenience function that returns RelationshipElement wrapped in ISubmodelElement
func RelationshipElementAsISubmodelElement(v *RelationshipElement) ISubmodelElement {
	return ISubmodelElement{
		RelationshipElement: v,
	}
}

// SubmodelElementAsISubmodelElement is a convenience function that returns SubmodelElement wrapped in ISubmodelElement
func SubmodelElementAsISubmodelElement(v *SubmodelElement) ISubmodelElement {
	return ISubmodelElement{
		SubmodelElement: v,
	}
}

// SubmodelElementCollectionAsISubmodelElement is a convenience function that returns SubmodelElementCollection wrapped in ISubmodelElement
func SubmodelElementCollectionAsISubmodelElement(v *SubmodelElementCollection) ISubmodelElement {
	return ISubmodelElement{
		SubmodelElementCollection: v,
	}
}

// SubmodelElementListAsISubmodelElement is a convenience function that returns SubmodelElementList wrapped in ISubmodelElement
func SubmodelElementListAsISubmodelElement(v *SubmodelElementList) ISubmodelElement {
	return ISubmodelElement{
		SubmodelElementList: v,
	}
}

// Unmarshal JSON data into one of the pointers in the struct
func (dst *ISubmodelElement) UnmarshalJSON(data []byte) error {
	var err error
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = newStrictDecoder(data).Decode(&jsonDict)
	if err != nil {
		return fmt.Errorf("Failed to unmarshal JSON into map for the discriminator lookup.")
	}

	// check if the discriminator value is 'AnnotatedRelationshipElement'
	if jsonDict["modelType"] == "AnnotatedRelationshipElement" {
		// try to unmarshal JSON data into AnnotatedRelationshipElement
		err = json.Unmarshal(data, &dst.AnnotatedRelationshipElement)
		if err == nil {
			return nil // data stored in dst.AnnotatedRelationshipElement, return on the first match
		} else {
			dst.AnnotatedRelationshipElement = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as AnnotatedRelationshipElement: %s", err.Error())
		}
	}

	// check if the discriminator value is 'BasicEventElement'
	if jsonDict["modelType"] == "BasicEventElement" {
		// try to unmarshal JSON data into BasicEventElement
		err = json.Unmarshal(data, &dst.BasicEventElement)
		if err == nil {
			return nil // data stored in dst.BasicEventElement, return on the first match
		} else {
			dst.BasicEventElement = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as BasicEventElement: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Blob'
	if jsonDict["modelType"] == "Blob" {
		// try to unmarshal JSON data into Blob
		err = json.Unmarshal(data, &dst.Blob)
		if err == nil {
			return nil // data stored in dst.Blob, return on the first match
		} else {
			dst.Blob = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as Blob: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Capability'
	if jsonDict["modelType"] == "Capability" {
		// try to unmarshal JSON data into SubmodelElement
		err = json.Unmarshal(data, &dst.SubmodelElement)
		if err == nil {
			return nil // data stored in dst.SubmodelElement, return on the first match
		} else {
			dst.SubmodelElement = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as SubmodelElement: %s", err.Error())
		}
	}

	// check if the discriminator value is 'DataElement'
	if jsonDict["modelType"] == "DataElement" {
		// try to unmarshal JSON data into SubmodelElement
		err = json.Unmarshal(data, &dst.SubmodelElement)
		if err == nil {
			return nil // data stored in dst.SubmodelElement, return on the first match
		} else {
			dst.SubmodelElement = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as SubmodelElement: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Entity'
	if jsonDict["modelType"] == "Entity" {
		// try to unmarshal JSON data into Entity
		err = json.Unmarshal(data, &dst.Entity)
		if err == nil {
			return nil // data stored in dst.Entity, return on the first match
		} else {
			dst.Entity = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as Entity: %s", err.Error())
		}
	}

	// check if the discriminator value is 'EventElement'
	if jsonDict["modelType"] == "EventElement" {
		// try to unmarshal JSON data into SubmodelElement
		err = json.Unmarshal(data, &dst.SubmodelElement)
		if err == nil {
			return nil // data stored in dst.SubmodelElement, return on the first match
		} else {
			dst.SubmodelElement = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as SubmodelElement: %s", err.Error())
		}
	}

	// check if the discriminator value is 'File'
	if jsonDict["modelType"] == "File" {
		// try to unmarshal JSON data into File
		err = json.Unmarshal(data, &dst.File)
		if err == nil {
			return nil // data stored in dst.File, return on the first match
		} else {
			dst.File = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as File: %s", err.Error())
		}
	}

	// check if the discriminator value is 'MultiLanguageProperty'
	if jsonDict["modelType"] == "MultiLanguageProperty" {
		// try to unmarshal JSON data into MultiLanguageProperty
		err = json.Unmarshal(data, &dst.MultiLanguageProperty)
		if err == nil {
			return nil // data stored in dst.MultiLanguageProperty, return on the first match
		} else {
			dst.MultiLanguageProperty = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as MultiLanguageProperty: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Operation'
	if jsonDict["modelType"] == "Operation" {
		// try to unmarshal JSON data into Operation
		err = json.Unmarshal(data, &dst.Operation)
		if err == nil {
			return nil // data stored in dst.Operation, return on the first match
		} else {
			dst.Operation = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as Operation: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Property'
	if jsonDict["modelType"] == "Property" {
		// try to unmarshal JSON data into Property
		err = json.Unmarshal(data, &dst.Property)
		if err == nil {
			return nil // data stored in dst.Property, return on the first match
		} else {
			dst.Property = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as Property: %s", err.Error())
		}
	}

	// check if the discriminator value is 'Range'
	if jsonDict["modelType"] == "Range" {
		// try to unmarshal JSON data into Range
		err = json.Unmarshal(data, &dst.Range)
		if err == nil {
			return nil // data stored in dst.Range, return on the first match
		} else {
			dst.Range = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as Range: %s", err.Error())
		}
	}

	// check if the discriminator value is 'ReferenceElement'
	if jsonDict["modelType"] == "ReferenceElement" {
		// try to unmarshal JSON data into ReferenceElement
		err = json.Unmarshal(data, &dst.ReferenceElement)
		if err == nil {
			return nil // data stored in dst.ReferenceElement, return on the first match
		} else {
			dst.ReferenceElement = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as ReferenceElement: %s", err.Error())
		}
	}

	// check if the discriminator value is 'RelationshipElement'
	if jsonDict["modelType"] == "RelationshipElement" {
		// try to unmarshal JSON data into RelationshipElement
		err = json.Unmarshal(data, &dst.RelationshipElement)
		if err == nil {
			return nil // data stored in dst.RelationshipElement, return on the first match
		} else {
			dst.RelationshipElement = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as RelationshipElement: %s", err.Error())
		}
	}

	// check if the discriminator value is 'SubmodelElementCollection'
	if jsonDict["modelType"] == "SubmodelElementCollection" {
		// try to unmarshal JSON data into SubmodelElementCollection
		err = json.Unmarshal(data, &dst.SubmodelElementCollection)
		if err == nil {
			return nil // data stored in dst.SubmodelElementCollection, return on the first match
		} else {
			dst.SubmodelElementCollection = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as SubmodelElementCollection: %s", err.Error())
		}
	}

	// check if the discriminator value is 'SubmodelElementList'
	if jsonDict["modelType"] == "SubmodelElementList" {
		// try to unmarshal JSON data into SubmodelElementList
		err = json.Unmarshal(data, &dst.SubmodelElementList)
		if err == nil {
			return nil // data stored in dst.SubmodelElementList, return on the first match
		} else {
			dst.SubmodelElementList = nil
			return fmt.Errorf("Failed to unmarshal ISubmodelElement as SubmodelElementList: %s", err.Error())
		}
	}

	return nil
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src ISubmodelElement) MarshalJSON() ([]byte, error) {
	if src.AnnotatedRelationshipElement != nil {
		return json.Marshal(&src.AnnotatedRelationshipElement)
	}

	if src.BasicEventElement != nil {
		return json.Marshal(&src.BasicEventElement)
	}

	if src.Blob != nil {
		return json.Marshal(&src.Blob)
	}

	if src.Entity != nil {
		return json.Marshal(&src.Entity)
	}

	if src.File != nil {
		return json.Marshal(&src.File)
	}

	if src.MultiLanguageProperty != nil {
		return json.Marshal(&src.MultiLanguageProperty)
	}

	if src.Operation != nil {
		return json.Marshal(&src.Operation)
	}

	if src.Property != nil {
		return json.Marshal(&src.Property)
	}

	if src.Range != nil {
		return json.Marshal(&src.Range)
	}

	if src.ReferenceElement != nil {
		return json.Marshal(&src.ReferenceElement)
	}

	if src.RelationshipElement != nil {
		return json.Marshal(&src.RelationshipElement)
	}

	if src.SubmodelElement != nil {
		return json.Marshal(&src.SubmodelElement)
	}

	if src.SubmodelElementCollection != nil {
		return json.Marshal(&src.SubmodelElementCollection)
	}

	if src.SubmodelElementList != nil {
		return json.Marshal(&src.SubmodelElementList)
	}

	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *ISubmodelElement) GetActualInstance() interface{} {
	if obj == nil {
		return nil
	}
	if obj.AnnotatedRelationshipElement != nil {
		return obj.AnnotatedRelationshipElement
	}

	if obj.BasicEventElement != nil {
		return obj.BasicEventElement
	}

	if obj.Blob != nil {
		return obj.Blob
	}

	if obj.Entity != nil {
		return obj.Entity
	}

	if obj.File != nil {
		return obj.File
	}

	if obj.MultiLanguageProperty != nil {
		return obj.MultiLanguageProperty
	}

	if obj.Operation != nil {
		return obj.Operation
	}

	if obj.Property != nil {
		return obj.Property
	}

	if obj.Range != nil {
		return obj.Range
	}

	if obj.ReferenceElement != nil {
		return obj.ReferenceElement
	}

	if obj.RelationshipElement != nil {
		return obj.RelationshipElement
	}

	if obj.SubmodelElement != nil {
		return obj.SubmodelElement
	}

	if obj.SubmodelElementCollection != nil {
		return obj.SubmodelElementCollection
	}

	if obj.SubmodelElementList != nil {
		return obj.SubmodelElementList
	}

	// all schemas are nil
	return nil
}

type NullableISubmodelElement struct {
	value *ISubmodelElement
	isSet bool
}

func (v NullableISubmodelElement) Get() *ISubmodelElement {
	return v.value
}

func (v *NullableISubmodelElement) Set(val *ISubmodelElement) {
	v.value = val
	v.isSet = true
}

func (v NullableISubmodelElement) IsSet() bool {
	return v.isSet
}

func (v *NullableISubmodelElement) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableISubmodelElement(val *ISubmodelElement) *NullableISubmodelElement {
	return &NullableISubmodelElement{value: val, isSet: true}
}

func (v NullableISubmodelElement) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableISubmodelElement) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
