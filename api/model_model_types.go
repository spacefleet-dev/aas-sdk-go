/*
BaSyx Asset Administration Shell Repository HTTP REST-API

The full description of the generic BaSyx Asset Administration Shell Repository HTTP REST-API

API version: v1
Contact: constantin.ziesche@bosch.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"encoding/json"
	"fmt"
)

// ModelTypes the model 'ModelTypes'
type ModelTypes string

// List of ModelTypes
const (
	MODELTYPES_ASSET                          ModelTypes = "Asset"
	MODELTYPES_ASSET_ADMINISTRATION_SHELL     ModelTypes = "AssetAdministrationShell"
	MODELTYPES_CONCEPT_DESCRIPTION            ModelTypes = "ConceptDescription"
	MODELTYPES_SUBMODEL                       ModelTypes = "Submodel"
	MODELTYPES_ACCESS_PERMISSION_RULE         ModelTypes = "AccessPermissionRule"
	MODELTYPES_ANNOTATED_RELATIONSHIP_ELEMENT ModelTypes = "AnnotatedRelationshipElement"
	MODELTYPES_BASIC_EVENT                    ModelTypes = "BasicEvent"
	MODELTYPES_BLOB                           ModelTypes = "Blob"
	MODELTYPES_CAPABILITY                     ModelTypes = "Capability"
	MODELTYPES_CONCEPT_DICTIONARY             ModelTypes = "ConceptDictionary"
	MODELTYPES_DATA_ELEMENT                   ModelTypes = "DataElement"
	MODELTYPES_FILE                           ModelTypes = "File"
	MODELTYPES_ENTITY                         ModelTypes = "Entity"
	MODELTYPES_EVENT                          ModelTypes = "Event"
	MODELTYPES_MULTI_LANGUAGE_PROPERTY        ModelTypes = "MultiLanguageProperty"
	MODELTYPES_OPERATION                      ModelTypes = "Operation"
	MODELTYPES_PROPERTY                       ModelTypes = "Property"
	MODELTYPES_RANGE                          ModelTypes = "Range"
	MODELTYPES_REFERENCE_ELEMENT              ModelTypes = "ReferenceElement"
	MODELTYPES_RELATIONSHIP_ELEMENT           ModelTypes = "RelationshipElement"
	MODELTYPES_SUBMODEL_ELEMENT               ModelTypes = "SubmodelElement"
	MODELTYPES_SUBMODEL_ELEMENT_COLLECTION    ModelTypes = "SubmodelElementCollection"
	MODELTYPES_VIEW                           ModelTypes = "View"
	MODELTYPES_GLOBAL_REFERENCE               ModelTypes = "GlobalReference"
	MODELTYPES_FRAGMENT_REFERENCE             ModelTypes = "FragmentReference"
	MODELTYPES_CONSTRAINT                     ModelTypes = "Constraint"
	MODELTYPES_FORMULA                        ModelTypes = "Formula"
	MODELTYPES_QUALIFIER                      ModelTypes = "Qualifier"
)

// All allowed values of ModelTypes enum
var AllowedModelTypesEnumValues = []ModelTypes{
	"Asset",
	"AssetAdministrationShell",
	"ConceptDescription",
	"Submodel",
	"AccessPermissionRule",
	"AnnotatedRelationshipElement",
	"BasicEvent",
	"Blob",
	"Capability",
	"ConceptDictionary",
	"DataElement",
	"File",
	"Entity",
	"Event",
	"MultiLanguageProperty",
	"Operation",
	"Property",
	"Range",
	"ReferenceElement",
	"RelationshipElement",
	"SubmodelElement",
	"SubmodelElementCollection",
	"View",
	"GlobalReference",
	"FragmentReference",
	"Constraint",
	"Formula",
	"Qualifier",
}

func (v *ModelTypes) UnmarshalJSON(src []byte) error {
	var value string
	err := json.Unmarshal(src, &value)
	if err != nil {
		return err
	}
	enumTypeValue := ModelTypes(value)
	for _, existing := range AllowedModelTypesEnumValues {
		if existing == enumTypeValue {
			*v = enumTypeValue
			return nil
		}
	}

	return fmt.Errorf("%+v is not a valid ModelTypes", value)
}

// NewModelTypesFromValue returns a pointer to a valid ModelTypes
// for the value passed as argument, or an error if the value passed is not allowed by the enum
func NewModelTypesFromValue(v string) (*ModelTypes, error) {
	ev := ModelTypes(v)
	if ev.IsValid() {
		return &ev, nil
	} else {
		return nil, fmt.Errorf("invalid value '%v' for ModelTypes: valid values are %v", v, AllowedModelTypesEnumValues)
	}
}

// IsValid return true if the value is valid for the enum, false otherwise
func (v ModelTypes) IsValid() bool {
	for _, existing := range AllowedModelTypesEnumValues {
		if existing == v {
			return true
		}
	}
	return false
}

// Ptr returns reference to ModelTypes value
func (v ModelTypes) Ptr() *ModelTypes {
	return &v
}

type NullableModelTypes struct {
	value *ModelTypes
	isSet bool
}

func (v NullableModelTypes) Get() *ModelTypes {
	return v.value
}

func (v *NullableModelTypes) Set(val *ModelTypes) {
	v.value = val
	v.isSet = true
}

func (v NullableModelTypes) IsSet() bool {
	return v.isSet
}

func (v *NullableModelTypes) Unset() {
	v.value = nil
	v.isSet = false
}

func NewNullableModelTypes(val *ModelTypes) *NullableModelTypes {
	return &NullableModelTypes{value: val, isSet: true}
}

func (v NullableModelTypes) MarshalJSON() ([]byte, error) {
	return json.Marshal(v.value)
}

func (v *NullableModelTypes) UnmarshalJSON(src []byte) error {
	v.isSet = true
	return json.Unmarshal(src, &v.value)
}
